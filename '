import os
import cv2
import numpy as np
import glob
import selectivesearch
from scipy import interpolate

#set paths to data
avd_root = '/net/bvisionserver3/playpen10/ammirato/Data/HalvedRohitData/'
#pick a scene
scene = 'Home_003_1'
#pick an image and semi-random bbox in that image
image_paths = glob.glob(os.path.join(avd_root,scene,'jpg_rgb','*.jpg'))
img_path = image_paths[np.random.choice(len(image_paths))]
d_img_path = img_path.replace('jpg_rgb','high_res_depth').replace('01.jpg','03.png')
rgb_img = cv2.imread(img_path)
d_img = cv2.imread(d_img_path)
#img_lbl, regions = selectivesearch.selective_search(rgb_img, scale=500, sigma=0.9, min_size=10)
xs = np.random.randint(100,high=rgb_img.shape[1]-100, size=2)
ys = np.random.randint(100,high=rgb_img.shape[0]-100, size=2)
box = [xs.min(),ys.min(),xs.max(),ys.max()]
#project points in bbox to world coordinates
#camera follows:  http://docs.opencv.org/master/db/d58/group__calib3d__fisheye.html#gsc.tab=0 

camera_params_fid = open(os.path.join(avd_root,scene,'cameras.txt'))
lines = [x for x in camera_params_fid]
lines = lines[-1].split()
intrinsic = np.zeros((3,3))
intrinsic[0,0] = float(lines[4])
intrinsic[0,2] = float(lines[6])
intrinsic[1,1] = float(lines[5])
intrinsic[1,2] = float(lines[7])
intrinsic[2,2] = float(1)

distortion = np.zeros(4)
distortion[0] = float(lines[8])
distortion[1] = float(lines[9])
distortion[2] = float(lines[10])
distortion[3] = float(lines[11])
camera_params_fid.close()

pixel_pos = np.mgrid[0:rgb_img.shape[0],0:rgb_img.shape[1]]
pixel_pos = pixel_pos.reshape((2,-1))

a = np.linspace(-1,1,2000)
b = np.linspace(-1,1,2000)
r = np.sqrt(np.square(a) + np.square(b))
theta = np.arctan(r)
thetad = theta * (1 + distortion[0]*(np.power(theta,2)) +
                      distortion[1]*(np.power(theta,4)) +
                      distortion[2]*(np.power(theta,6)) +
                      distortion[3]*(np.power(theta,8)))
xx = (thetad/r) * a
yy = thetad/r *b

index_map_mult = 1000
index_map_add = 1000
a_map = np.zeros(a.shape)
b_map = np.zeros(b.shape)
a_map[np.floor(xx*index_map_mult + index_map_add).astype(np.int)] = a
b_map[np.floor(yy*index_map_mult + index_map_add).astype(np.int)] = b 
x = np.arange(0,len(a_map))
idx = a_map.nonzero()
fa = interpolate.interp1d(x[idx],a_map[idx])
fb = interpolate.interp1d(x[idx],b_map[idx])
xnew = np.arange(28,len(a_map)-28)
a_map[28:-28] = fa(xnew)
b_map[28:-28] = fb(xnew)

#find an image that sees the projected points, and is within 90 veiwing angle, and check scale
#project points back onto second image to get new bounding box

